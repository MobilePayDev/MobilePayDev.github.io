"use strict";(self.webpackChunkmobile_pay_merchant_payments_documentation=self.webpackChunkmobile_pay_merchant_payments_documentation||[]).push([[7933],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),p=c(n),u=r,m=p["".concat(s,".").concat(u)]||p[u]||d[u]||o;return n?a.createElement(m,i(i({ref:t},h),{},{components:n})):a.createElement(m,i({ref:t},h))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},91589:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>h});var a=n(87462),r=(n(67294),n(3905)),o=n(89728);const i={sidebar_position:4,pagination_next:null},l="Refresh tokens",s={unversionedId:"app-payments/authentication/open-id/refresh-tokens",id:"app-payments/authentication/open-id/refresh-tokens",title:"Refresh tokens",description:"",source:"@site/docs/app-payments/authentication/open-id/refresh-tokens.mdx",sourceDirName:"app-payments/authentication/open-id",slug:"/app-payments/authentication/open-id/refresh-tokens",permalink:"/docs/app-payments/authentication/open-id/refresh-tokens",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,pagination_next:null},sidebar:"docsSidebar",previous:{title:"Tokens",permalink:"/docs/app-payments/authentication/open-id/tokens"}},c={},h=[],p={toc:h};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"refresh-tokens"},"Refresh tokens"),(0,r.kt)(o.ZP,{mdxType:"OpenIdPage"}))}d.isMDXComponent=!0},89728:(e,t,n)=>{n.d(t,{ZP:()=>i});var a=n(87462),r=(n(67294),n(3905));const o={toc:[{value:"Step 4: Refresh token",id:"step-4-refresh-token",level:2},{value:"Keep the session alive by using the refresh token",id:"keep-the-session-alive-by-using-the-refresh-token",level:3},{value:"Invalid tokens",id:"invalid-tokens",level:3},{value:"PKCE / Code Challenge",id:"pkce--code-challenge",level:3},{value:"How Can Access be Revoked?",id:"how-can-access-be-revoked",level:3},{value:"Best Practice",id:"best-practice",level:3}]};function i(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"step-4-refresh-token"},"Step 4: Refresh token"),(0,r.kt)("p",null,"To get a refresh token, you must include the offline_access scope when you initiate an authentication request through the authorize endpoint. To refresh your access token, using the Refresh Token you already got during authorization, make a POST request to the token endpoint. Read more ",(0,r.kt)("a",{parentName:"p",href:"https://auth0.com/docs/tokens/refresh-token/current#use-a-refresh-token"},"here"),"."),(0,r.kt)("h3",{id:"keep-the-session-alive-by-using-the-refresh-token"},"Keep the session alive by using the refresh token"),(0,r.kt)("p",null,"Whenever an ",(0,r.kt)("inlineCode",{parentName:"p"},"access_token")," is required to access a protected resource, a client may use a ",(0,r.kt)("inlineCode",{parentName:"p"},"refresh_token")," to get a new Access Token issued by the Authentication Server. Although ",(0,r.kt)("inlineCode",{parentName:"p"},"access_token")," can be renewed at any time using ",(0,r.kt)("inlineCode",{parentName:"p"},"refresh_token"),"s, they should be renewed when old ones have expired, or when getting access to a new resource for the first time. When the ",(0,r.kt)("inlineCode",{parentName:"p"},"access_token")," expires, the ",(0,r.kt)("inlineCode",{parentName:"p"},"refresh_token")," can be used to obtain a fresh ",(0,r.kt)("inlineCode",{parentName:"p"},"access_token")," with the same permissions, without further involvement from a user. When the ",(0,r.kt)("inlineCode",{parentName:"p"},"access_token")," expires, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"refresh_token")," to get a new ",(0,r.kt)("inlineCode",{parentName:"p"},"access_token")," by using the token endpoint as shown below:"),(0,r.kt)("p",null,"Sample request:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"POST https://api.sandbox.mobilepay.dk/merchant-authentication-openidconnect/connect/token\nContent-Type: application/x-www-form-urlencoded\nHost: api.sandbox.mobilepay.dk\nBody:\ngrant_type=refresh_token\nrefresh_token=01cab0f861cdb89c326604cae408ae6e8c57e72c70c84143b93e04bbecb8c748\nclient_id=some.test.client.received.in.zipfile\nclient_secret=mysecret.received.in.zip.file\n")),(0,r.kt)("p",null,"Explanation of parameters:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"grant_type")),(0,r.kt)("td",{parentName:"tr",align:null},"A way to specify how the client will interact with the server"),(0,r.kt)("td",{parentName:"tr",align:null},'Must be set to "refresh_token"'),(0,r.kt)("td",{parentName:"tr",align:null},"Yes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"refresh_token")),(0,r.kt)("td",{parentName:"tr",align:null},"The refresh token to be used"),(0,r.kt)("td",{parentName:"tr",align:null},"The existing refresh token"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"client_id")),(0,r.kt)("td",{parentName:"tr",align:null},"The client_id that you received by zip file"),(0,r.kt)("td",{parentName:"tr",align:null},"The client_id given in the zip file"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"client_secret")),(0,r.kt)("td",{parentName:"tr",align:null},"The client_secret that you received by zip file."),(0,r.kt)("td",{parentName:"tr",align:null},"The client_secret given in the zip file."),(0,r.kt)("td",{parentName:"tr",align:null},"Yes")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Refresh_tokens")," are long-lived. This means when a client gets one from a server, this token must be stored securely to keep it from being used by potential attackers. Therefore, it is not safe to store them in the browser. If a ",(0,r.kt)("inlineCode",{parentName:"p"},"refresh_token")," is leaked, it may be used to obtain new ",(0,r.kt)("inlineCode",{parentName:"p"},"access_tokens")," (and access protected resources) until it is blacklisted or invalidated.\nTo get a ",(0,r.kt)("inlineCode",{parentName:"p"},"refresh_token"),", you must include the ",(0,r.kt)("inlineCode",{parentName:"p"},"offline_access")," scope when you initiate an authorization request through the authorize endpoint."),(0,r.kt)("p",null,"If the refresh token is valid, then you get back a new access token:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\n    "id-token" : "MIOf-U1zQbyfa3[...]MUfJHhvnUqIut9ClH0xjlDXGJAyqo"\n    "access_token": "eyJhbGciOiJ[...]K1Sun9bA",\n    "token_type": "Bearer",\n    "expires_in": 300,\n    "token_type": "Bearer",\n    "refresh_token": "MIOf-U1zQbyfa3[...]MUfJHhvnUqIut9ClH0xjlDXGJAyqo"\n}\n')),(0,r.kt)("h3",{id:"invalid-tokens"},"Invalid tokens"),(0,r.kt)("p",null,"If you make an API call using an invalid token, you will receive a ",(0,r.kt)("inlineCode",{parentName:"p"},"401 Unauthorized")," response back from the server. A token could be invalid and in need of regeneration if:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It has expired."),(0,r.kt)("li",{parentName:"ul"},"The user has revoked the permission they initially granted "),(0,r.kt)("li",{parentName:"ul"},"You have changed the (scope) your application is requesting."),(0,r.kt)("li",{parentName:"ul"},"A subsequent OpenID Connect flow that generated a new access token. The previous token will be invalidated if running Single Use tokens.\nYou should only ask for a new token if the access_token has expired or you want to refresh the claims contained in the ID Token. For example, it's a bad practice to call the endpoint to get a new access_token every time you call an API, if you already have an active access_token. ")),(0,r.kt)("p",null,"Refresh tokens can expire but are long-lived. They are subject to strict storage requirements to ensure they are not leaked.  Since a predictable expiry time is not the only contributing factor to token invalidation, it is very important that you code your applications to properly handle an encounter with a 401 error by redirecting the user back to the start of the authorization workflow."),(0,r.kt)("h3",{id:"pkce--code-challenge"},"PKCE / Code Challenge"),(0,r.kt)("p",null,"For more information on the PKCE protocol and the security considerations, see ",(0,r.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7636"},"IETF RFC 7636"),". "),(0,r.kt)("p",null,"MobilePay supports the ",(0,r.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7636"},"Proof Key for Code Exchange"),' protocol to make the authorization flow more secure. A unique code verifier is created for every authorization request, and its transformed value, called "code_challenge", is sent to the authorization server to obtain the authorization code. Example: ',(0,r.kt)("a",{parentName:"p",href:"https://github.com/MobilePayDev/MobilePay-Invoice/blob/master/ClientExamples/ConsoleClientExample/Program.cs#L43%20"},"C# example"),". Note that it is hidden in the framework. ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/MobilePayDev/MobilePay-Invoice/blob/master/ClientExamples/ConsoleClientExample/Program.cs#L43%20"},"This line")," calls a IdentityModel feature which automatically uses PKCE. "),(0,r.kt)("p",null,"Terminology: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"code verifier"),": A cryptographically random string that is used to correlate the authorization request to the token request. The client creates a one-time secret (code verifier)  that is used to generate a code challenge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"code challenge"),": A challenge derived from the code verifier that is sent in the authorization request, to be verified against later. Code challenge is also referred to as the code that you generated, and made cryptographically secure and sent to us in /authorize endpoint property code challenge. ")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"PKCE Parameters")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"code_verifier"),": A random value of 43-128 characters. Created by the client. Stored on the server upon an authorization request. The recommended value is a 32-octet sequence that is base64url-encoded to create a 43-octet URL safe string."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"code_challenge_method"),": The code challenge method used to generate the code challenge value. S256 \u2013 SHA256 encoding is performed: code_challenge=base64url(sha256(code_verifier))"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"code_challenge"),": Value based on the code_verifier and the code_challenge_method.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"private string CreateCodeChallenge()\n{\n    _codeVerifier = RandomNumberGenerator.CreateUniqueId();\n    var sha256 = HashAlgorithmProvider.OpenAlgorithm(HashAlgorithm.Sha256);\n    var challengeBuffer = sha256.HashData(\n        CryptographicBuffer.CreateFromByteArray(Encoding.UTF8.GetBytes(_codeVerifier)));\n    byte[] challengeBytes;\n    CryptographicBuffer.CopyToByteArray(challengeBuffer, out challengeBytes);\n    return Base64Url.Encode(challengeBytes);\n}\n")),(0,r.kt)("p",null,"Here is how IdentityServer do the validation: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"var codeVerifierBytes = Encoding.ASCII.GetBytes(codeVerifier);"),(0,r.kt)("li",{parentName:"ul"},"var hashedBytes = codeVerifierBytes.Sha256();"),(0,r.kt)("li",{parentName:"ul"},"var transformedCodeVerifier = Base64Url.Encode(hashedBytes);"),(0,r.kt)("li",{parentName:"ul"},"return TimeConstantComparer.IsEqual(transformedCodeVerifier.Sha256(), codeChallenge);")),(0,r.kt)("p",null,"If you get an error that the code challenge is either too short or too long, please update the value of code_challenge to meet the requirements and try again. Regarding code_verifier, it has the same length requirements as code challenge.  "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"CodeChallengeMinLength = 43"),(0,r.kt)("li",{parentName:"ul"},"CodeChallengeMaxLength = 128")),(0,r.kt)("p",null,"The method for calculating code_challenge is ",(0,r.kt)("em",{parentName:"p"},"base64urlencoder(Sha256(code_verifier))")," when challenge method is S256. "),(0,r.kt)("h3",{id:"how-can-access-be-revoked"},"How Can Access be Revoked?"),(0,r.kt)("p",null,"It might be useful for you to know, what happens in theory, if your merchant decides to revoke the consent. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The merchant can revoke the consent for the Integrator. It's done from the MobilePay Portal, specifically the menu item Settings \u2192 Integration. The Tab is empty if no consent is granted.  The merchant needs to have a SuperManager role in the MobilePay Portal in order to be allowed to remove the consent."),(0,r.kt)("li",{parentName:"ul"},"Subscriptions and Invoice merchants should have max one integrator. When the integrator has been granted consent, the integrator will be able to retrieve information about the Subscriptions Provider, and make API calls on behalf of the merchant. "),(0,r.kt)("li",{parentName:"ul"},"Access can be revoked at any time by the merchant though, and once consent is revoked, the integrator won't be able to access merchant data with their token, nor will they be able to refresh the token.  "),(0,r.kt)("li",{parentName:"ul"},"If the merchant is changing from one integrator to another, the consent process should be coordinated between the merchant and the new integrator. The merchant will need to go through the authorize process again. ")),(0,r.kt)("h3",{id:"best-practice"},"Best Practice"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Focus on having logic, that ensures that when you use ",(0,r.kt)("inlineCode",{parentName:"li"},"access token"),", then you also check if it is expired. The logic should tell you, for how long the ",(0,r.kt)("inlineCode",{parentName:"li"},"access token")," is valid, so that you can know, when it is time to refresh the ",(0,r.kt)("inlineCode",{parentName:"li"},"access token"),",  without making a call to MobilePay service and receiving 401. ",(0,r.kt)("strong",{parentName:"li"},"When")," it is expired, then you can use ",(0,r.kt)("inlineCode",{parentName:"li"},"refresh_token")," to get a new valid  ",(0,r.kt)("inlineCode",{parentName:"li"},"access token"),"."),(0,r.kt)("li",{parentName:"ul"},"The  ",(0,r.kt)("inlineCode",{parentName:"li"},"refresh_token"),"  are subject to strict storage requirements to ensure that they are not leaked."),(0,r.kt)("li",{parentName:"ul"},"Although  ",(0,r.kt)("inlineCode",{parentName:"li"},"access token")," can be renewed at any time using ",(0,r.kt)("inlineCode",{parentName:"li"},"refresh_token"),", they should only be renewed when old ones have expired, or when getting access to a new resource for the first time.")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"You should only ask for a new token if the ",(0,r.kt)("inlineCode",{parentName:"p"},"access_token")," has expired or you want to refresh the claims contained in the ID Token. For example, it's a bad practice to call the endpoint to get a new ",(0,r.kt)("inlineCode",{parentName:"p"},"access_token")," every time you call an API.\nPlease avoid hitting the rate limits in that will throttle the amount of requests to this endpoint that can be executed using the same token from the same IP.")),(0,r.kt)("p",null,"The long-lived ",(0,r.kt)("inlineCode",{parentName:"p"},"refresh_tokens")," must never be exposed. If you have any suspicion that they might be, you should contact us at ",(0,r.kt)("a",{parentName:"p",href:"mailto:developer@mobilepay.dk"},"developer@mobilepay.dk")," or the merchant in question, so the token can be revoked. "),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Refresh_tokens"),"  must be stored securely by an application since they allow a user to remain authenticated essentially forever."))}i.isMDXComponent=!0}}]);